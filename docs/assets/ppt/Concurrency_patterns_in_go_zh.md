# Go è¯­è¨€ä¸­çš„å¹¶å‘æ¨¡å¼

## å¹¶å‘å…³ä¹**è®¾è®¡**

- **è®¾è®¡**ç¨‹åºï¼Œä½¿å…¶æˆä¸ºä¸€ç»„ç‹¬ç«‹çš„è¿›ç¨‹  
- **è®¾è®¡**è¿™äº›è¿›ç¨‹ï¼Œä½¿å®ƒä»¬æœ€ç»ˆå¯ä»¥å¹¶è¡Œè¿è¡Œ  
- **è®¾è®¡**ä»£ç ï¼Œä»¥ç¡®ä¿æœ€ç»ˆç»“æœå§‹ç»ˆä¸€è‡´  

## å¹¶å‘çš„ç»†èŠ‚

- é€šè¿‡è¯†åˆ«ç‹¬ç«‹ä»»åŠ¡æ¥ç»„ç»‡ä»£ç ï¼ˆå’Œæ•°æ®ï¼‰  
- æ— ç«äº‰æ¡ä»¶ï¼ˆrace conditionsï¼‰  
- æ— æ­»é”ï¼ˆdeadlocksï¼‰  
- å¢åŠ  worker æ•°é‡ = æ›´å¿«çš„æ‰§è¡Œé€Ÿåº¦  

## é€šä¿¡é¡ºåºè¿›ç¨‹ï¼ˆCSPï¼‰

- Tony Hoareï¼Œ1978  
1. æ¯ä¸ªè¿›ç¨‹éƒ½æ˜¯ä¸ºé¡ºåºæ‰§è¡Œè€Œæ„å»ºçš„  
2. è¿›ç¨‹ä¹‹é—´é€šè¿‡é€šé“ï¼ˆchannelï¼‰è¿›è¡Œæ•°æ®é€šä¿¡ï¼Œæ²¡æœ‰å…±äº«çŠ¶æ€ï¼  
3. é€šè¿‡å¢åŠ ç›¸åŒç±»å‹çš„è¿›ç¨‹æ¥æ‰©å±•  

## é€šé“ï¼ˆChannelsï¼‰

- å¯ä»¥å°†å…¶æƒ³è±¡ä¸ºä¸€æ¡æ°´æ¡¶ä¼ é€’é“¾  
- ç”± 3 ä¸ªéƒ¨åˆ†ç»„æˆï¼šå‘é€ç«¯ã€ç¼“å†²åŒºã€æ¥æ”¶ç«¯  
- ç¼“å†²åŒºæ˜¯å¯é€‰çš„

![](../../images/bucket_chain.png)

### é˜»å¡é€šé“ï¼ˆBlocking Channelsï¼‰

```go
unbuffered := make(chan int)

// 1) é˜»å¡
a := <- unbuffered

// 2) é˜»å¡
unbuffered <- 1

// 3) åŒæ­¥
go func() { <- unbuffered }()
unbuffered <- 1


buffered := make(chan int, 1)
// 4) ä»ç„¶é˜»å¡
a := <- buffered

// 5) æ­£å¸¸
buffered <- 1

// 6) é˜»å¡ï¼ˆç¼“å†²åŒºå·²æ»¡ï¼‰
buffered <- 2
```

#### é˜»å¡ç ´åå¹¶å‘

- è®°ä½ï¼š
    - æ— æ­»é”  
    - å¢åŠ  worker æ•°é‡ = æ›´å¿«çš„æ‰§è¡Œé€Ÿåº¦  
- é˜»å¡å¯èƒ½å¯¼è‡´æ­»é”  
- é˜»å¡å¯èƒ½é˜»ç¢ç¨‹åºçš„æ‰©å±•  

### å…³é—­é€šé“ï¼ˆClosing Channelsï¼‰

- `close` å‘é€ä¸€ä¸ªç‰¹æ®Šçš„ `closed` æ¶ˆæ¯  
- æ¥æ”¶ç«¯åœ¨æŸä¸ªæ—¶åˆ»ä¼šæ£€æµ‹åˆ° `closed`ï¼Œè¡¨ç¤ºæ— æ›´å¤šæ•°æ®  
- å¦‚æœå…³é—­åä»ç„¶å°è¯•å‘é€æ•°æ®ï¼Œä¼šå¯¼è‡´ **panic**ï¼

```go
c := make(chan int)
close(c)

fmt.Println(<-c) // æ¥æ”¶å¹¶æ‰“å°
// è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ

// 0, false

// - æ¥æ”¶æ“ä½œæ€»æ˜¯è¿”å›ä¸¤ä¸ªå€¼  
// - 0 æ˜¯ int ç±»å‹çš„é›¶å€¼  
// - false è¡¨ç¤º `æ²¡æœ‰æ›´å¤šæ•°æ®` æˆ– `è¿”å›å€¼æ— æ•ˆ`
```

### `select` è¯­å¥

- ç±»ä¼¼äº `switch` è¯­å¥ï¼Œä½†ç”¨äºé€šé“æ“ä½œ  
- case è¯­å¥çš„é¡ºåº**æ— å…³ç´§è¦**  
- ä¹Ÿå¯ä»¥æœ‰ `default` åˆ†æ”¯  
- `select` è¯­å¥ä¼šé€‰æ‹©**ç¬¬ä¸€ä¸ªéé˜»å¡çš„ case**ï¼ˆæ— è®ºæ˜¯å‘é€è¿˜æ˜¯æ¥æ”¶ï¼‰  

#### ä½¿é€šé“éé˜»å¡

```go
func TryReceive(c <-chan int) (data int, more, ok bool) {
    select {
        case data, more = <- c:
            return data, more, true
        default: // å½“ c é˜»å¡æ—¶æ‰§è¡Œ
            return 0, true, false
    }
}
```

```go
func TryReceiveWithTimeout(c <-chan int, duration time.Duration) (data int, more, ok bool) {
    select {
        case data, more = <- c:
            return data, more, true
        case <- time.After(duration): // time.After è¿”å›ä¸€ä¸ªé€šé“
            return 0, true, false
    }
}
```

#### è®¾è®¡æ•°æ®æµ

- é€šé“æ˜¯æ•°æ®æµ  
- å¤„ç†å¤šä¸ªæ•°æ®æµæ˜¯ `select` çš„çœŸæ­£å¼ºå¤§ä¹‹å¤„ 

![](../../images/data_flow.png)

**Fan-outï¼ˆæ‰‡å‡ºï¼‰**ï¼šFan-out æŒ‡çš„æ˜¯ä»ä¸€ä¸ªè¾“å…¥é€šé“ï¼Œå°†æ•°æ®åˆ†å‘åˆ°å¤šä¸ª goroutine è¿›è¡Œå¹¶å‘å¤„ç†ã€‚

**Funnelï¼ˆæ±‡èšï¼‰**ï¼šFunnel æ–¹å¼æ˜¯å¤šä¸ªè¾“å…¥é€šé“çš„æ•°æ®åˆå¹¶åˆ°ä¸€ä¸ªé€šé“ä¸­ï¼Œé€šå¸¸ç”¨äºå¤šä¸ªæ•°æ®æºåˆå¹¶å¤„ç†ã€‚

**Turnoutï¼ˆåˆ†æµï¼‰**ï¼šTurnout ä»£è¡¨çš„æ˜¯æ•°æ®ä»ä¸€ä¸ªè¾“å…¥é€šé“ï¼ŒæŒ‰ç…§ç‰¹å®šçš„è§„åˆ™è¢«å‘é€åˆ°ä¸åŒçš„é€šé“ï¼ˆå¯èƒ½æ˜¯ä¸åŒçš„ goroutine è¿›è¡Œä¸åŒçš„å¤„ç†ï¼‰ã€‚

##### æ‰‡å‡ºï¼ˆFan-outï¼‰

```go
func Fanout(In <-chan int, OutA, OutB chan int) {
    for data := range In { // ç›´åˆ°é€šé“å…³é—­
        select { // å‘é€åˆ°ç¬¬ä¸€ä¸ªéé˜»å¡çš„é€šé“
            case OutA <- data:
            case OutB <- data:
        }
    }
}
```

##### æ‰‡å…¥ï¼ˆTurnoutï¼‰

```go
func Turnout(InA, InB <-chan int, OutA, OutB chan int) {
    for {
        select { // ä»ç¬¬ä¸€ä¸ªéé˜»å¡çš„é€šé“æ¥æ”¶
            case data, more = <- InA:
            case data, more = <- InB:
        }

        if !more {
            return
        }

        select { // å‘é€åˆ°ç¬¬ä¸€ä¸ªéé˜»å¡çš„é€šé“
            case OutA <- data:
            case OutB <- data:
        }
    }
}
```

##### é€€å‡ºé€šé“ï¼ˆQuit Channelï¼‰

```go
func Turnout(Quit <-chan int, InA, InB, OutA, OutB chan int) {
    for {
        select {
            case data = <- InA:
            case data = <- InB:

            case <- Quit: // å…³é—­é€šé“ä¼šå‘é€ä¸€ä¸ªæ¶ˆæ¯
                close(InA) // åæ¨¡å¼ï¼ˆanti-patternï¼‰
                close(InB)

                Fanout(InA, OutA, OutB) // å¤„ç†å‰©ä½™æ•°æ®
                Fanout(InB, OutA, OutB)
                return
        }
    }
}
```

### é€šé“çš„å±€é™æ€§

- å¯èƒ½ä¼šå¯¼è‡´æ­»é”  
- é€šé“ä¼ é€’çš„æ˜¯æ•°æ®çš„ **å‰¯æœ¬**ï¼Œå¯èƒ½å½±å“æ€§èƒ½  
- ä¼ é€’æŒ‡é’ˆçš„é€šé“å¯èƒ½ä¼šå¼•å‘ç«äº‰æ¡ä»¶  
- å¦‚ä½•å¤„ç† **â€œå¤©ç„¶å…±äº«â€** çš„æ•°æ®ç»“æ„ï¼ˆå¦‚ç¼“å­˜ã€æ³¨å†Œè¡¨ï¼‰ï¼Ÿ  

!!! note "å¦‚ä½•ç†è§£â€œä¼ é€’æŒ‡é’ˆçš„é€šé“å¯èƒ½ä¼šå¼•å‘ç«äº‰æ¡ä»¶â€ï¼Ÿ"

    #### ğŸ“ å¦‚ä½•ç†è§£â€œä¼ é€’æŒ‡é’ˆçš„é€šé“å¯èƒ½ä¼šå¼•å‘ç«äº‰æ¡ä»¶â€ï¼Ÿ

    åœ¨ Go è¯­è¨€çš„å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œ**é€šè¿‡é€šé“ä¼ é€’æŒ‡é’ˆï¼ˆè€Œéå€¼ï¼‰** å¯èƒ½ä¼šå¯¼è‡´å¤šä¸ª goroutine å…±äº«å¹¶ä¿®æ”¹åŒä¸€å—å†…å­˜ï¼Œä»è€Œå¼•å‘ **æ•°æ®ç«äº‰ï¼ˆRace Conditionï¼‰**ã€‚  

    **é—®é¢˜çš„æ ¹æºï¼š**

    - **é€šé“ä¼ é€’çš„æ˜¯æŒ‡é’ˆï¼Œè€Œä¸æ˜¯æ•°æ®çš„æ‹·è´**
    - **å¤šä¸ª goroutine å¯èƒ½åŒæ—¶è®¿é—®å’Œä¿®æ”¹åŒä¸€å—å†…å­˜**
    - **æœªæ­£ç¡®åŒæ­¥æ—¶ï¼Œä¼šå¯¼è‡´ç«äº‰æ¡ä»¶ï¼Œå‡ºç°æœªå®šä¹‰è¡Œä¸º**


    ##### é”™è¯¯ç¤ºä¾‹ï¼šä¼ é€’æŒ‡é’ˆå¯¼è‡´æ•°æ®ç«äº‰

    ```go
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    type Data struct {
        value int
    }

    func main() {
        ch := make(chan *Data)
        wg := sync.WaitGroup{}
        wg.Add(2)

        // ç”Ÿäº§è€…
        go func() {
            defer wg.Done()
            data := &Data{value: 0} // åˆ›å»ºæ•°æ®
            for i := 0; i < 5; i++ {
                data.value = i  // ä¿®æ”¹å€¼
                fmt.Println("Sending:", data.value)
                ch <- data // å‘é€æŒ‡é’ˆ
                time.Sleep(time.Millisecond * 100)
            }
            close(ch)
        }()

        // æ¶ˆè´¹è€…
        go func() {
            defer wg.Done()
            for data := range ch {
                fmt.Println("Received:", data.value) // å¯èƒ½è¯»å–åˆ°ä¸ä¸€è‡´çš„æ•°æ®
            }
        }()

        wg.Wait()
    }
    ```

    ##### é—®é¢˜åˆ†æ

    1. **é€šé“ä¼ é€’çš„æ˜¯æŒ‡é’ˆ `*Data`**ï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…éƒ½æŒ‡å‘åŒä¸€å—å†…å­˜ã€‚
    2. **æ•°æ®ç«äº‰å‘ç”Ÿ**ï¼š
    - ç”Ÿäº§è€… `data.value = i` åœ¨ä¿®æ”¹ `value` åå†å‘é€æŒ‡é’ˆã€‚
    - ä½† **æ¶ˆè´¹è€…æ­¤æ—¶å¯èƒ½å·²ç»åœ¨è¯»å– `data.value`**ï¼Œå¯¼è‡´æ¥æ”¶åˆ°çš„æ•°æ®æ˜¯ä¸ç¡®å®šçš„ã€‚
    3. **å¯èƒ½å¯¼è‡´æ¶ˆè´¹è€…è¯»å–åˆ°çš„æ•°æ®ä¸å‘é€çš„ä¸ä¸€è‡´**ï¼Œä¾‹å¦‚ï¼š
    ```
    Sending: 0
    Sending: 1
    Received: 1  // æœ¬åº”æ”¶åˆ° 0ï¼Œä½†æ”¶åˆ° 1ï¼Œæ•°æ®ç«äº‰å¯¼è‡´çš„é”™è¯¯
    Sending: 2
    Received: 2
    ```
    è¿™é‡Œï¼Œæ¶ˆè´¹è€…æœ¬åº”æŒ‰ç…§ `0 -> 1 -> 2 ...` é¡ºåºæ¥æ”¶ï¼Œä½†å¯èƒ½ç›´æ¥è·³è¿‡æŸäº›å€¼ã€‚

    ##### æ­£ç¡®ç¤ºä¾‹ï¼šä¼ é€’æ•°æ®å‰¯æœ¬ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆ

    ```go
    package main

    import (
        "fmt"
        "sync"
        "time"
    )

    type Data struct {
        value int
    }

    func main() {
        ch := make(chan Data) // ä¼ é€’å€¼ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆ
        wg := sync.WaitGroup{}
        wg.Add(2)

        // ç”Ÿäº§è€…
        go func() {
            defer wg.Done()
            for i := 0; i < 5; i++ {
                data := Data{value: i} // åˆ›å»ºæ•°æ®
                fmt.Println("Sending:", data.value)
                ch <- data // ä¼ é€’å€¼çš„æ‹·è´ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆ
                time.Sleep(time.Millisecond * 100)
            }
            close(ch)
        }()

        // æ¶ˆè´¹è€…
        go func() {
            defer wg.Done()
            for data := range ch {
                fmt.Println("Received:", data.value) // è¯»å–åˆ°çš„æ•°æ®ä¸ä¼šè¢«ç”Ÿäº§è€…ä¿®æ”¹
            }
        }()

        wg.Wait()
    }
    ```

    ##### ä¸ºä»€ä¹ˆè¿™ä¸ªç‰ˆæœ¬ä¸ä¼šæœ‰æ•°æ®ç«äº‰ï¼Ÿ

    1. **é€šé“ä¼ é€’çš„æ˜¯ `Data` ç»“æ„ä½“çš„å€¼æ‹·è´ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆ**ï¼Œæ¯ä¸ª goroutine éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„æ•°æ®å‰¯æœ¬ã€‚
    2. **ç”Ÿäº§è€…ä¿®æ”¹ `data.value` ä¸ä¼šå½±å“æ¶ˆè´¹è€…**ï¼Œé¿å…æ•°æ®ç«äº‰ã€‚
    3. **ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§**ï¼Œæ¶ˆè´¹è€…æ¥æ”¶åˆ°çš„æ•°æ®ä¸ä¼šè¢«ç”Ÿäº§è€…æ„å¤–ä¿®æ”¹ã€‚


    ##### æ€»ç»“

    ###### ä¸ºä»€ä¹ˆâ€œä¼ é€’æŒ‡é’ˆçš„é€šé“å¯èƒ½ä¼šå¼•å‘ç«äº‰æ¡ä»¶â€ï¼Ÿ

    - **æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜æ˜¯å…±äº«çš„**
    - **å¤šä¸ª goroutine åŒæ—¶è®¿é—®å’Œä¿®æ”¹åŒä¸€å—å†…å­˜**
    - **å¯¼è‡´æ•°æ®ç«äº‰ï¼Œå‡ºç°æœªå®šä¹‰è¡Œä¸º**

    ###### å¦‚ä½•é¿å…ï¼Ÿ

    âœ… **æ¨èä¼ é€’å€¼ï¼Œè€Œä¸æ˜¯æŒ‡é’ˆ**  
    âœ… **å¦‚æœå¿…é¡»ä¼ é€’æŒ‡é’ˆï¼Œéœ€ä½¿ç”¨ `sync.Mutex` æˆ– `sync/atomic` è¿›è¡ŒåŒæ­¥**  
    âœ… **åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œå°½å¯èƒ½å‡å°‘å…±äº«çŠ¶æ€ï¼Œä½¿ç”¨æ¶ˆæ¯ä¼ é€’æ–¹å¼è¿›è¡Œæ•°æ®å¤„ç†**

!!! note "å¦‚ä½•ç†è§£â€œå¤©ç„¶å…±äº«â€çš„æ•°æ®ç»“æ„ï¼ˆå¦‚ç¼“å­˜ã€æ³¨å†Œè¡¨ï¼‰ï¼Ÿ"

    #### ğŸ“ å¦‚ä½•ç†è§£â€œå¤©ç„¶å…±äº«â€çš„æ•°æ®ç»“æ„ï¼ˆå¦‚ç¼“å­˜ã€æ³¨å†Œè¡¨ï¼‰ï¼Ÿ

    åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œ**â€œå¤©ç„¶å…±äº«â€** çš„æ•°æ®ç»“æ„æŒ‡çš„æ˜¯ï¼š

    - **å¤šä¸ª goroutine éœ€è¦åŒæ—¶è®¿é—®å’Œä¿®æ”¹çš„æ•°æ®ç»“æ„**ï¼ˆå¦‚ç¼“å­˜ã€æ³¨å†Œè¡¨ã€è®¡æ•°å™¨ç­‰ï¼‰ã€‚
    - **æ— æ³•ç®€å•åœ°ç”¨é€šé“ä¼ é€’å‰¯æœ¬**ï¼Œå› ä¸ºæ•°æ®éœ€è¦å…¨å±€å…±äº«ã€‚
    - **å¦‚æœæ²¡æœ‰æ­£ç¡®çš„åŒæ­¥ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«äº‰ï¼ˆRace Conditionï¼‰**ã€‚

    å…¸å‹çš„ä¾‹å­ï¼š

    1. **ç¼“å­˜ï¼ˆCacheï¼‰**ï¼šå¤šä¸ª goroutine è¯»å–å’Œæ›´æ–°ç¼“å­˜ä¸­çš„æ•°æ®ã€‚
    2. **æ³¨å†Œè¡¨ï¼ˆRegistryï¼‰**ï¼šå­˜å‚¨å…¨å±€é…ç½®ä¿¡æ¯ï¼Œå¤šä¸ª goroutine å¯èƒ½éœ€è¦è®¿é—®å’Œä¿®æ”¹ã€‚
    3. **å…¨å±€è®¡æ•°å™¨**ï¼šå¦‚è¯·æ±‚æ•°ç»Ÿè®¡ï¼Œéœ€è¦å¤šä¸ª goroutine å¹¶å‘å¢åŠ è®¡æ•°ã€‚

    ##### é”™è¯¯ç¤ºä¾‹ï¼šå¤šä¸ª goroutine è®¿é—®å…±äº« mapï¼Œå¯¼è‡´æ•°æ®ç«äº‰

    ```go
    package main

    import (
        "fmt"
        "time"
    )

    var cache = make(map[string]int) // å…±äº« map

    func writeToCache(key string, value int) {
        cache[key] = value // å¯èƒ½æœ‰æ•°æ®ç«äº‰
    }

    func readFromCache(key string) int {
        return cache[key] // å¯èƒ½è¯»å–åˆ°æœªåŒæ­¥çš„æ•°æ®
    }

    func main() {
        go writeToCache("a", 1) // å¹¶å‘å†™
        go fmt.Println(readFromCache("a")) // å¹¶å‘è¯»
        time.Sleep(time.Second) // ç­‰å¾… goroutine æ‰§è¡Œ
    }
    ```

    **âš  é—®é¢˜ï¼š**

    - `cache` æ˜¯ **å¤©ç„¶å…±äº«** çš„æ•°æ®ç»“æ„ï¼Œå› ä¸ºå¤šä¸ª goroutine éœ€è¦è®¿é—®å®ƒã€‚
    - **å¤šä¸ª goroutine å¯èƒ½åŒæ—¶è¯»å†™ mapï¼Œå¯¼è‡´æ•°æ®ç«äº‰ï¼ˆRace Conditionï¼‰**ã€‚
    - **Go 1.6 åŠä»¥ä¸Šç‰ˆæœ¬åœ¨å¹¶å‘å†™ map æ—¶ä¼šç›´æ¥ panic**ï¼š
    ```
    fatal error: concurrent map writes
    ```

    **æ­£ç¡®ç¤ºä¾‹ 1ï¼šä½¿ç”¨ `sync.Mutex` ä¿æŠ¤å…±äº«æ•°æ®**

    ä½¿ç”¨ `sync.Mutex` è®©å¤šä¸ª goroutine ä¾æ¬¡è®¿é—®å…±äº«æ•°æ®ï¼Œç¡®ä¿å¹¶å‘å®‰å…¨ï¼š
    ```go
    package main

    import (
        "fmt"
        "sync"
    )

    var (
        cache = make(map[string]int)
        mu    sync.Mutex
    )

    func writeToCache(key string, value int) {
        mu.Lock()
        cache[key] = value
        mu.Unlock()
    }

    func readFromCache(key string) int {
        mu.Lock()
        defer mu.Unlock()
        return cache[key]
    }

    func main() {
        var wg sync.WaitGroup
        wg.Add(2)

        go func() {
            defer wg.Done()
            writeToCache("a", 1)
        }()

        go func() {
            defer wg.Done()
            fmt.Println(readFromCache("a"))
        }()

        wg.Wait()
    }
    ```

    âœ… **ä¸ºä»€ä¹ˆè¿™ä¸ªç‰ˆæœ¬æ˜¯å®‰å…¨çš„ï¼Ÿ**

    1. **`sync.Mutex` ç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª goroutine è®¿é—® `cache`**ã€‚
    2. **é¿å…äº†æ•°æ®ç«äº‰ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§**ã€‚

    **æ­£ç¡®ç¤ºä¾‹ 2ï¼šä½¿ç”¨ `sync.RWMutex` å…è®¸å¤šä¸ª goroutine å¹¶å‘è¯»å–**

    å¦‚æœå¤§éƒ¨åˆ†æ“ä½œæ˜¯ **è¯»å–ï¼ˆè¯»å¤šå†™å°‘ï¼‰**ï¼Œå¯ä»¥ä½¿ç”¨ `sync.RWMutex`ï¼š
    ```go
    package main

    import (
        "fmt"
        "sync"
    )

    var (
        cache = make(map[string]int)
        mu    sync.RWMutex
    )

    func writeToCache(key string, value int) {
        mu.Lock() // åªæœ‰å†™æ“ä½œéœ€è¦ç‹¬å é”
        cache[key] = value
        mu.Unlock()
    }

    func readFromCache(key string) int {
        mu.RLock() // è¯»é”ï¼Œå…è®¸å¤šä¸ª goroutine åŒæ—¶è¯»å–
        defer mu.RUnlock()
        return cache[key]
    }

    func main() {
        var wg sync.WaitGroup
        wg.Add(3)

        go func() {
            defer wg.Done()
            writeToCache("a", 1)
        }()

        go func() {
            defer wg.Done()
            fmt.Println("Read 1:", readFromCache("a"))
        }()

        go func() {
            defer wg.Done()
            fmt.Println("Read 2:", readFromCache("a"))
        }()

        wg.Wait()
    }
    ```

    âœ… **`sync.RWMutex` ä¼˜åŠ¿**

    - **å¤šä¸ª goroutine å¯ä»¥åŒæ—¶è¯»å–æ•°æ®ï¼Œæé«˜å¹¶å‘æ€§èƒ½**ã€‚
    - **å†™å…¥æ—¶ä»ç„¶éœ€è¦åŠ é”ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§**ã€‚

    **æ­£ç¡®ç¤ºä¾‹ 3ï¼šä½¿ç”¨ `sync.Map` é€‚ç”¨äºé«˜å¹¶å‘è¯»å†™**

    Go 1.9 åŠä»¥ä¸Šæä¾›äº† `sync.Map`ï¼Œé€‚ç”¨äºé«˜å¹¶å‘åœºæ™¯ï¼š
    ```go
    package main

    import (
        "fmt"
        "sync"
    )

    var cache sync.Map

    func writeToCache(key string, value int) {
        cache.Store(key, value) // å¹¶å‘å®‰å…¨çš„å­˜å‚¨
    }

    func readFromCache(key string) (int, bool) {
        val, ok := cache.Load(key) // å¹¶å‘å®‰å…¨çš„è¯»å–
        if !ok {
            return 0, false
        }
        return val.(int), true
    }

    func main() {
        var wg sync.WaitGroup
        wg.Add(3)

        go func() {
            defer wg.Done()
            writeToCache("a", 1)
        }()

        go func() {
            defer wg.Done()
            if val, ok := readFromCache("a"); ok {
                fmt.Println("Read:", val)
            } else {
                fmt.Println("Key not found")
            }
        }()

        go func() {
            defer wg.Done()
            if val, ok := readFromCache("a"); ok {
                fmt.Println("Read:", val)
            } else {
                fmt.Println("Key not found")
            }
        }()

        wg.Wait()
    }
    ```

    âœ… **`sync.Map` ä¼˜åŠ¿**

    1. **å†…éƒ¨å·²ç»å®ç°äº†å¹¶å‘æ§åˆ¶ï¼ˆæ— é”æˆ–å°‘é”ï¼‰ï¼Œé€‚åˆé«˜å¹¶å‘è¯»å†™**ã€‚
    2. **æ¯” `sync.Mutex` æ–¹æ¡ˆæ›´é«˜æ•ˆ**ï¼Œé€‚ç”¨äº **é¢‘ç¹è¯»å†™çš„å…±äº«æ•°æ®**ã€‚

    ##### æ€»ç»“

    | æ–¹æ¡ˆ | é€‚ç”¨åœºæ™¯ | è¯»å†™æ€§èƒ½ |
    |------|--------|--------|
    | `sync.Mutex` | è¯»å†™éƒ½å¾ˆé¢‘ç¹çš„æƒ…å†µ | **è¯»å†™éƒ½éœ€è¦åŠ é”ï¼Œå½±å“æ€§èƒ½** |
    | `sync.RWMutex` | è¯»å¤šå†™å°‘çš„æƒ…å†µ | **å…è®¸å¤šä¸ªè¯»ï¼Œå†™ä»éœ€åŠ é”** |
    | `sync.Map` | é«˜å¹¶å‘è®¿é—®çš„å…¨å±€æ•°æ®ï¼ˆå¦‚ç¼“å­˜ã€æ³¨å†Œè¡¨ï¼‰ | **æ— é”æˆ–å°‘é”ï¼Œé«˜æ•ˆ** |

    ##### ç»“è®º

    å¯¹äº **â€œå¤©ç„¶å…±äº«â€** çš„æ•°æ®ç»“æ„ï¼ˆå¦‚ç¼“å­˜ã€æ³¨å†Œè¡¨ï¼‰ï¼š

    1. ä¸èƒ½ç®€å•ç”¨é€šé“ä¼ é€’å‰¯æœ¬ï¼Œå› ä¸ºæ•°æ®æ˜¯å…¨å±€å…±äº«çš„ã€‚
    2. éœ€è¦ä½¿ç”¨ `sync.Mutex`ã€`sync.RWMutex` æˆ– `sync.Map` è¿›è¡ŒåŒæ­¥ï¼š

    - **`sync.Mutex`**ï¼šé€‚ç”¨äº **è¯»å†™å‡è¡¡** çš„æƒ…å†µã€‚
    - **`sync.RWMutex`**ï¼šé€‚ç”¨äº **è¯»å¤šå†™å°‘** çš„æƒ…å†µã€‚
    - **`sync.Map`**ï¼šé€‚ç”¨äº **é«˜å¹¶å‘è¯»å†™**ï¼Œæ˜¯ **æ— é”æˆ–å°‘é”æ–¹æ¡ˆ**ã€‚
    
## äº’æ–¥é”ï¼ˆMutexï¼‰ä¸æ˜¯æœ€ä½³è§£å†³æ–¹æ¡ˆ

- **äº’æ–¥é”å°±åƒå•æ‰€**  
    - ä½¿ç”¨æ—¶é—´è¶Šé•¿ï¼Œç­‰å¾…é˜Ÿåˆ—è¶Šé•¿  
- è¯»/å†™é”åªèƒ½ **å‡å°‘** é—®é¢˜ï¼Œä½†ä¸èƒ½å®Œå…¨é¿å…  
- ä½¿ç”¨å¤šä¸ªäº’æ–¥é”æœ€ç»ˆä¼šå¯¼è‡´æ­»é”  
- æ€»ä½“è€Œè¨€ï¼Œä¸æ˜¯æœ€ä½³æ–¹æ¡ˆ  

### ä¸‰ç§ä»£ç æ‰§è¡Œæ¨¡å¼

- **é˜»å¡ï¼ˆBlockingï¼‰** = ä»£ç å¯èƒ½ä¼šé•¿æ—¶é—´åœæ»  
- **æ— é”ï¼ˆLock-freeï¼‰** = è‡³å°‘æœ‰ä¸€éƒ¨åˆ†ç¨‹åºå§‹ç»ˆåœ¨æ‰§è¡Œ  
- **æ— ç­‰å¾…ï¼ˆWait-freeï¼‰** = æ‰€æœ‰éƒ¨åˆ†çš„ç¨‹åºå§‹ç»ˆåœ¨æ‰§è¡Œ  

## åŸå­æ“ä½œï¼ˆAtomic Operationsï¼‰

- `sync/atomic` åŒ…  
- `Store`ã€`Load`ã€`Add`ã€`Swap`ã€`CompareAndSwap`  
- åº•å±‚æ˜ å°„åˆ° CPU çº§åˆ«çš„çº¿ç¨‹å®‰å…¨æŒ‡ä»¤  
- ä»…é€‚ç”¨äºæ•´æ•°ç±»å‹  
- ä»…æ¯”æ™®é€šæ“ä½œæ…¢ 10-60 å€ï¼ˆæ¯”äº’æ–¥é”æ›´é«˜æ•ˆï¼‰  

### è‡ªæ—‹ CASï¼ˆSpinning CASï¼‰

- éœ€è¦ä¸€ä¸ª **çŠ¶æ€å˜é‡** å’Œä¸€ä¸ª **free** å¸¸é‡  
- åœ¨å¾ªç¯ä¸­ä½¿ç”¨ `CASï¼ˆCompareAndSwapï¼‰`ï¼š
    - å¦‚æœçŠ¶æ€ **ä¸æ˜¯ free**ï¼Œåˆ™ç»§ç»­å°è¯•  
    - å¦‚æœçŠ¶æ€ **æ˜¯ free**ï¼Œåˆ™ä¿®æ”¹çŠ¶æ€ï¼Œè·å–æ‰€æœ‰æƒ  

```go
type Spinlock struct {
    state *int32
}

const free = int32(0)

func (l *Spinlock) Lock() {
    for !atomic.CompareAndSwapInt32(l.state, free, 42) {
        runtime.Gosched()
    }
}

func (l *Spinlock) Unlock() {
    atomic.StoreInt32(l.state, free)
}
```

### ç¥¨æ®å­˜å‚¨ï¼ˆTicket Storeï¼‰

- éœ€è¦ï¼š
    - **ç´¢å¼•åŒ–æ•°æ®ç»“æ„**
    - **ç¥¨æ®ï¼ˆticketï¼‰**
    - **å®Œæˆï¼ˆdoneï¼‰å˜é‡**  
- æ¯ä¸ªæ–°ç¥¨æ®å€¼é€’å¢ï¼Œä¿è¯å”¯ä¸€æ€§  
- ç¥¨æ®ä½œä¸ºç´¢å¼•å­˜å‚¨æ•°æ®  
- `done` å˜é‡è¡¨ç¤ºå¯è¯»èŒƒå›´  

```go
type TicketStore struct {
    ticket *uint64
    done   *uint64
    slots  []string
}

func (ts *TicketStore) Put(s string) {
    t := atomic.AddUint64(ts.ticket, 1) - 1
    slots[t] = s
    for !atomic.CompareAndSwapUint64(ts.done, t, t+1) {
        runtime.Gosched()
    }
}

func (ts *TicketStore) GetDone() []string {
    return ts.slots[:atomic.LoadUint64(ts.done)+1]
}
```

### è°ƒè¯•éé˜»å¡ä»£ç 

- æˆ‘ç§°ä¹‹ä¸º â€œ**æŒ‡ä»¤æŒ‡é’ˆæ¸¸æˆ**â€ï¼ˆThe Instruction Pointer Gameï¼‰ã€‚
- è§„åˆ™å¦‚ä¸‹ï¼š
    - æ‰“å¼€ **ä¸¤ä¸ªçª—å£**ï¼ˆå³ä¸¤ä¸ª Goroutineï¼‰ï¼Œå®ƒä»¬è¿è¡Œç›¸åŒçš„ä»£ç ã€‚
    - ä½ æœ‰ **ä¸€ä¸ªæŒ‡ä»¤æŒ‡é’ˆ**ï¼Œå®ƒä¼šä¾æ¬¡æ‰§è¡Œä½ çš„ä»£ç ã€‚
    - ä½ å¯ä»¥åœ¨ **ä»»ä½•ä¸€æ¡æŒ‡ä»¤** å¤„ **åˆ‡æ¢** çª—å£ï¼ˆå³åœ¨ä¸åŒ Goroutine ä¹‹é—´åˆ‡æ¢æ‰§è¡Œé¡ºåºï¼‰ã€‚
    - **è§‚å¯Ÿ** å˜é‡çš„å€¼ï¼ŒæŸ¥æ‰¾å¯èƒ½å‘ç”Ÿçš„æ•°æ®ç«äº‰ï¼ˆRace Conditionï¼‰ã€‚

### è°ƒè¯•ä»¥æ’é™¤æ•…éšœ

```go
func (ts *TicketStore) Puts(s string) {
    ticket := atomic.AddUint64(ts.next, 1) -1
    slots[ticket] = s
    atomic.AddUint64(ts.done, 1)
}
```

### éé˜»å¡ä»£ç çš„æŒ‡å¯¼åŸåˆ™

- ä¸è¦åœ¨**åŸå­æ“ä½œ**å’Œ**éåŸå­æ“ä½œ**ä¹‹é—´åˆ‡æ¢
- ç›®æ ‡æ˜¯**åˆ©ç”¨å¹¶å¼ºåŒ–å”¯ä¸€æ€§**çš„æƒ…å†µ
- é¿å…**åŒæ—¶æ›´æ”¹ä¸¤ä¸ªå˜é‡**

    - æœ‰æ—¶å¯ä»¥åˆ©ç”¨**ä½è¿ç®—**æ¥è§£å†³é—®é¢˜
    - æœ‰æ—¶**åˆç†çš„æ“ä½œé¡ºåº**å¯ä»¥é¿å…é—®é¢˜
    - æœ‰æ—¶**æ ¹æœ¬æ— æ³•é¿å…**ï¼Œéœ€è¦å¦å¯»ä»–æ³•

!!! note "å¦‚ä½•ç†è§£â€œç›®æ ‡æ˜¯åˆ©ç”¨å¹¶å¼ºåŒ–å”¯ä¸€æ€§çš„æƒ…å†µâ€ï¼Ÿ"

    #### ğŸ“ å¦‚ä½•ç†è§£â€œç›®æ ‡æ˜¯åˆ©ç”¨å¹¶å¼ºåŒ–å”¯ä¸€æ€§çš„æƒ…å†µâ€ï¼Ÿ

    åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œ**å”¯ä¸€æ€§ï¼ˆUniquenessï¼‰** æŒ‡çš„æ˜¯ï¼š

    - æ¯ä¸ªèµ„æºæˆ–æ“ä½œéƒ½åº”è¯¥æœ‰ä¸€ä¸ªå”¯ä¸€çš„â€œæ‰€æœ‰è€…â€æˆ–â€œå¤„ç†è€…â€ã€‚
    - é€šè¿‡å”¯ä¸€æ€§ï¼Œé¿å…ç«äº‰æ¡ä»¶ï¼ˆRace Conditionsï¼‰ï¼Œå‡å°‘é”çš„ä½¿ç”¨ï¼Œæé«˜å¹¶å‘æ•ˆç‡ã€‚

    - å…¸å‹çš„åšæ³•åŒ…æ‹¬ï¼š

    - **ä½¿ç”¨å”¯ä¸€ IDï¼ˆå¦‚è‡ªå¢è®¡æ•°å™¨ã€UUIDï¼‰**
    - **ä½¿ç”¨åŸå­æ“ä½œç¡®ä¿å”¯ä¸€æ€§**
    - **ç¡®ä¿æŸä¸ªä»»åŠ¡åªæœ‰ä¸€ä¸ª goroutine åœ¨å¤„ç†**

    ##### ç¤ºä¾‹ï¼šåˆ©ç”¨å”¯ä¸€æ€§ç¡®ä¿ä»»åŠ¡ä»…è¢«ä¸€ä¸ª goroutine å¤„ç†

    ###### é”™è¯¯ç¤ºä¾‹ï¼šå¤šä¸ª goroutine å¯èƒ½åŒæ—¶å¤„ç†åŒä¸€ä¸ªä»»åŠ¡

    ```go
    package main

    import (
        "fmt"
        "sync"
    )

    type TaskQueue struct {
        tasks []int
        mu    sync.Mutex
    }

    func (q *TaskQueue) GetTask() (int, bool) {
        q.mu.Lock()
        defer q.mu.Unlock()
        if len(q.tasks) == 0 {
            return 0, false
        }
        task := q.tasks[0]
        q.tasks = q.tasks[1:] // å–å‡ºä»»åŠ¡
        return task, true
    }

    func worker(id int, q *TaskQueue, wg *sync.WaitGroup) {
        defer wg.Done()
        for {
            task, ok := q.GetTask()
            if !ok {
                return
            }
            fmt.Printf("Worker %d processing task %d\n", id, task)
        }
    }

    func main() {
        queue := &TaskQueue{tasks: []int{1, 2, 3, 4, 5}}
        wg := sync.WaitGroup{}

        for i := 0; i < 3; i++ { // 3 ä¸ª worker å¹¶å‘å¤„ç†
            wg.Add(1)
            go worker(i, queue, &wg)
        }

        wg.Wait()
    }
    ```

    **é—®é¢˜ï¼š**

    - è¿™é‡Œä¾èµ– `sync.Mutex` æ¥ä¿è¯ä»»åŠ¡çš„å”¯ä¸€æ€§ï¼Œä½†é”çš„å¼€é”€è¾ƒå¤§ï¼Œ**æ¯æ¬¡è·å–ä»»åŠ¡æ—¶éƒ½è¦åŠ é”**ï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚

    ###### æ­£ç¡®ç¤ºä¾‹ï¼šåˆ©ç”¨åŸå­æ“ä½œå’Œå”¯ä¸€æ€§æ ‡è¯†ç¬¦

    æ”¹è¿›æ–¹æ³•ï¼šç”¨ **`sync/atomic`** ç¡®ä¿ä»»åŠ¡åªä¼šè¢«ä¸€ä¸ª goroutine å¤„ç†ï¼Œè€Œä¸éœ€è¦é”ã€‚

    ```go
    package main

    import (
        "fmt"
        "sync"
        "sync/atomic"
    )

    type TaskQueue struct {
        tasks   []int
        current int64 // åŸå­è®¡æ•°å™¨ï¼Œç¡®ä¿æ¯ä¸ªä»»åŠ¡åªè¢«é¢†å–ä¸€æ¬¡
    }

    func (q *TaskQueue) GetTask() (int, bool) {
        index := atomic.AddInt64(&q.current, 1) - 1
        if int(index) >= len(q.tasks) {
            return 0, false
        }
        return q.tasks[index], true
    }

    func worker(id int, q *TaskQueue, wg *sync.WaitGroup) {
        defer wg.Done()
        for {
            task, ok := q.GetTask()
            if !ok {
                return
            }
            fmt.Printf("Worker %d processing task %d\n", id, task)
        }
    }

    func main() {
        queue := &TaskQueue{tasks: []int{1, 2, 3, 4, 5}}
        wg := sync.WaitGroup{}

        for i := 0; i < 3; i++ { // 3 ä¸ª worker å¹¶å‘å¤„ç†
            wg.Add(1)
            go worker(i, queue, &wg)
        }

        wg.Wait()
    }
    ```

    ###### ä¸ºä»€ä¹ˆè¿™æ®µä»£ç æ›´ä¼˜ï¼Ÿ

    1. **åˆ©ç”¨ `atomic.AddInt64` ç”Ÿæˆå”¯ä¸€çš„ä»»åŠ¡ç´¢å¼•**ï¼Œé¿å…ç«äº‰æ¡ä»¶ã€‚
    2. **æ— é”ï¼ˆLock-Freeï¼‰æ–¹æ¡ˆ**ï¼Œæ¯” `sync.Mutex` ç‰ˆæœ¬æ€§èƒ½æ›´é«˜ï¼Œå‡å°‘é”ç«äº‰ã€‚
    3. **ä»»åŠ¡å”¯ä¸€æ€§å¾—åˆ°ä¿è¯**ï¼Œæ¯ä¸ªä»»åŠ¡åªä¼šè¢«ä¸€ä¸ª worker å¤„ç†ã€‚

    ##### æ€»ç»“

    **åˆ©ç”¨å¹¶å¼ºåŒ–å”¯ä¸€æ€§**ï¼Œå°±æ˜¯åœ¨å¹¶å‘ç¯å¢ƒä¸‹ç¡®ä¿æŸäº›èµ„æºã€ä»»åŠ¡æˆ–æ•°æ®åªæœ‰ä¸€ä¸ª goroutine è®¿é—®æˆ–ä¿®æ”¹ã€‚  
    - **ç”¨åŸå­æ“ä½œç”Ÿæˆå”¯ä¸€ IDï¼ˆå¦‚ `atomic.AddInt64`ï¼‰** æ¥ç¡®ä¿ä»»åŠ¡å”¯ä¸€æ€§ã€‚  
    - **å‡å°‘é”çš„ä½¿ç”¨ï¼Œæé«˜å¹¶å‘æ€§èƒ½**ã€‚  
    - **ç¡®ä¿ä»»åŠ¡ä¸ä¼šè¢«å¤šä¸ª goroutine é‡å¤å¤„ç†**ï¼Œé¿å…ç«äº‰æ¡ä»¶ï¼ˆRace Conditionsï¼‰ã€‚

??? "â€œæœ‰æ—¶å¯ä»¥åˆ©ç”¨**ä½è¿ç®—**æ¥è§£å†³é—®é¢˜â€ï¼Œè¿™å¥è¯å¦‚ä½•ç†è§£ï¼Ÿ"

    #### ğŸ“ å¦‚ä½•ç†è§£â€œæœ‰æ—¶å¯ä»¥åˆ©ç”¨ä½è¿ç®—æ¥è§£å†³é—®é¢˜â€ï¼Ÿ

    åˆ©ç”¨ **ä½è¿ç®—** æ¥è§£å†³å¹¶å‘é—®é¢˜ï¼Œä¸»è¦æ˜¯å› ä¸º **ä½è¿ç®—æ˜¯åŸå­æ“ä½œ**ï¼Œå¯ä»¥åœ¨ **ä¸ä½¿ç”¨é”** çš„æƒ…å†µä¸‹ç®¡ç†å¤šä¸ªçŠ¶æ€ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ã€‚ä¾‹å¦‚ï¼š

    - **ä½¿ç”¨ä½æ ‡å¿—å­˜å‚¨å¤šä¸ªçŠ¶æ€**ï¼Œé¿å…å¤šä¸ªå˜é‡çš„ç«äº‰æ¡ä»¶
    - **ä½¿ç”¨åŸå­æ“ä½œä¿®æ”¹çŠ¶æ€**ï¼Œç¡®ä¿å¹¶å‘å®‰å…¨

    ##### ç¤ºä¾‹ï¼šä½¿ç”¨ä½è¿ç®—è¿›è¡ŒåŸå­çŠ¶æ€ç®¡ç†

    å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå¹¶å‘åº”ç”¨ç¨‹åºï¼Œå…¶ä¸­æŸä¸ªèµ„æºå¯èƒ½å¤„äº **è¯»ä¸­ (READING)**ã€**å†™ä¸­ (WRITING)** æˆ– **å°±ç»ª (READY)** ä¸‰ç§çŠ¶æ€ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª `int32` å˜é‡çš„ä¸åŒ **ä½** æ¥è¡¨ç¤ºè¿™äº›çŠ¶æ€ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å¤šä¸ª `bool` å˜é‡ã€‚

    ##### ç¤ºä¾‹ä»£ç 

    ```go
    package main

    import (
        "fmt"
        "sync/atomic"
    )

    const (
        READY    = 1 << 0 // 0001 (è¡¨ç¤ºå°±ç»ª)
        READING  = 1 << 1 // 0010 (è¡¨ç¤ºæ­£åœ¨è¯»å–)
        WRITING  = 1 << 2 // 0100 (è¡¨ç¤ºæ­£åœ¨å†™å…¥)
    )

    type Resource struct {
        state int32 // ä½¿ç”¨ int32 å­˜å‚¨çŠ¶æ€
    }

    // è®¾ç½®çŠ¶æ€
    func (r *Resource) SetState(newState int32) {
        atomic.OrInt32(&r.state, newState) // ä½¿ç”¨ OR æ“ä½œè®¾ç½®æ–°çŠ¶æ€
    }

    // æ¸…é™¤çŠ¶æ€
    func (r *Resource) ClearState(oldState int32) {
        atomic.AndInt32(&r.state, ^oldState) // ä½¿ç”¨ AND+å–å æ¥æ¸…é™¤æŸä¸ªçŠ¶æ€
    }

    // æ£€æŸ¥çŠ¶æ€
    func (r *Resource) HasState(checkState int32) bool {
        return atomic.LoadInt32(&r.state)&checkState != 0 // ä½¿ç”¨ AND æ“ä½œæ£€æŸ¥çŠ¶æ€
    }

    func main() {
        r := &Resource{}

        r.SetState(READING) // è®¾ç½®æ­£åœ¨è¯»å–çŠ¶æ€
        fmt.Println("Reading:", r.HasState(READING)) // true
        fmt.Println("Writing:", r.HasState(WRITING)) // false

        r.SetState(WRITING) // åŒæ—¶è®¾ç½®æ­£åœ¨å†™å…¥çŠ¶æ€
        fmt.Println("Reading:", r.HasState(READING)) // true
        fmt.Println("Writing:", r.HasState(WRITING)) // true

        r.ClearState(READING) // æ¸…é™¤è¯»å–çŠ¶æ€
        fmt.Println("Reading:", r.HasState(READING)) // false
        fmt.Println("Writing:", r.HasState(WRITING)) // true
    }
    ```

    è§£é‡Šè¯´æ˜ï¼š

    1. **ä½¿ç”¨ `int32` å˜é‡çš„ä¸åŒä½æ¥å­˜å‚¨å¤šä¸ªçŠ¶æ€**ï¼š

        - `READY = 0001`
        - `READING = 0010`
        - `WRITING = 0100`
    
    2. **ä½¿ç”¨ `atomic.OrInt32(&r.state, newState)` æ¥è®¾ç½®çŠ¶æ€**ï¼š
    - `OR` æ“ä½œï¼ˆ`|`ï¼‰å¯ä»¥åœ¨ä¸å½±å“å…¶ä»–ä½çš„æƒ…å†µä¸‹ **æ‰“å¼€æŸä¸ªçŠ¶æ€ä½**ã€‚

    3. **ä½¿ç”¨ `atomic.AndInt32(&r.state, ^oldState)` æ¥æ¸…é™¤çŠ¶æ€**ï¼š
    - `AND` æ“ä½œï¼ˆ`&`ï¼‰ç»“åˆ `^` å–åï¼Œå¯ä»¥ **åªæ¸…é™¤ç‰¹å®šçš„çŠ¶æ€ä½ï¼Œè€Œä¸å½±å“å…¶ä»–ä½**ã€‚

    4. **ä½¿ç”¨ `atomic.LoadInt32(&r.state)&checkState != 0` æ¥æ£€æŸ¥çŠ¶æ€**ï¼š

    - `AND` æ“ä½œï¼ˆ`&`ï¼‰å¯ä»¥æ£€æµ‹æŸä¸ªä½æ˜¯å¦è¢«è®¾ç½®ã€‚

    ##### ä¸ºä»€ä¹ˆè¿™æ ·åšï¼Ÿ

    - **é¿å…å¤šä¸ªå˜é‡çš„ç«äº‰æ¡ä»¶**ï¼Œå› ä¸ºçŠ¶æ€ç®¡ç†æ˜¯**åŸå­æ“ä½œ**ï¼Œä¸ä¼šå¯¼è‡´æ•°æ®ç«äº‰ã€‚
    - **æ— é”çŠ¶æ€ç®¡ç†**ï¼Œç›¸æ¯”äºä½¿ç”¨ `sync.Mutex` å¯èƒ½æé«˜æ€§èƒ½ã€‚
    - **å¯æ‰©å±•æ€§å¼º**ï¼Œå¦‚æœæœ‰æ–°çš„çŠ¶æ€ï¼Œå¯ä»¥ç›´æ¥æ·»åŠ æ–°çš„ä½ï¼Œè€Œä¸éœ€è¦æ–°å¢å˜é‡ã€‚

!!! note "â€œæœ‰æ—¶**åˆç†çš„æ“ä½œé¡ºåº**å¯ä»¥é¿å…é—®é¢˜â€ï¼Œè¿™å¥è¯å¦‚ä½•ç†è§£ï¼Ÿ"

    #### ğŸ“ åˆç†çš„æ“ä½œé¡ºåºå¦‚ä½•é¿å…å¹¶å‘é—®é¢˜ï¼Ÿ

    åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œ**æ“ä½œçš„é¡ºåº** å¯èƒ½å½±å“æ•°æ®çš„æ­£ç¡®æ€§å’Œç¨‹åºçš„ç¨³å®šæ€§ã€‚åˆç†å®‰æ’æ“ä½œé¡ºåºå¯ä»¥ï¼š

    1. **é¿å…æ•°æ®ç«äº‰ï¼ˆrace conditionï¼‰**  
    2. **ç¡®ä¿å†…å­˜å¯è§æ€§ï¼ˆmemory visibilityï¼‰**  
    3. **å‡å°‘é”çš„ä½¿ç”¨ï¼Œæé«˜å¹¶å‘æ€§èƒ½**  


    ##### ç¤ºä¾‹ï¼šåˆç†çš„æ“ä½œé¡ºåºé¿å…æ•°æ®ç«äº‰

    ##### é”™è¯¯ç¤ºä¾‹ï¼šå…ˆæ›´æ–°å…±äº«æ•°æ®ï¼Œå†é€šçŸ¥å…¶ä»–çº¿ç¨‹

    ```go
    package main

    import (
        "fmt"
        "sync"
    )

    type Data struct {
        value int
        mu    sync.Mutex
    }

    func main() {
        d := &Data{}
        wg := sync.WaitGroup{}
        wg.Add(2)

        // çº¿ç¨‹ 1ï¼šå…ˆæ›´æ–°æ•°æ®ï¼Œå†è§£é”
        go func() {
            d.mu.Lock()
            d.value = 42 // æ›´æ–°å…±äº«å˜é‡
            d.mu.Unlock()
            wg.Done()
        }()

        // çº¿ç¨‹ 2ï¼šè¯»å–æ•°æ®
        go func() {
            d.mu.Lock()
            fmt.Println("Value:", d.value) // å¯èƒ½è¯»å–åˆ°æœªæ›´æ–°çš„å€¼
            d.mu.Unlock()
            wg.Done()
        }()

        wg.Wait()
    }
    ```

    **é—®é¢˜ï¼š**
    
    - å¯èƒ½ä¼šå¯¼è‡´ **æ•°æ®ç«äº‰ï¼ˆRace Conditionï¼‰**ï¼Œå› ä¸ºå¦ä¸€ä¸ªçº¿ç¨‹åœ¨æ•°æ®å®Œå…¨æ›´æ–°ä¹‹å‰å°±è¯»å–äº† `value`ã€‚


    ##### æ­£ç¡®ç¤ºä¾‹ï¼šå…ˆæ›´æ–°æ•°æ®ï¼Œå†è§£é”ï¼Œå†é€šçŸ¥å…¶ä»–çº¿ç¨‹

    ```go
    package main

    import (
        "fmt"
        "sync"
    )

    type Data struct {
        value int
        mu    sync.Mutex
    }

    func main() {
        d := &Data{}
        wg := sync.WaitGroup{}
        wg.Add(2)

        // çº¿ç¨‹ 1ï¼šå…ˆæ›´æ–°æ•°æ®ï¼Œå†è§£é”
        go func() {
            d.mu.Lock()
            d.value = 42 // æ›´æ–°å…±äº«å˜é‡
            d.mu.Unlock() // å…ˆè§£é”
            wg.Done()
        }()

        // çº¿ç¨‹ 2ï¼šè¯»å–æ•°æ®
        go func() {
            wg.Wait() // ç­‰å¾…çº¿ç¨‹ 1 å®Œæˆï¼Œç¡®ä¿æ•°æ®å·²ç»æ›´æ–°
            d.mu.Lock()
            fmt.Println("Value:", d.value) // è¯»å–åˆ°çš„æ˜¯ 42
            d.mu.Unlock()
        }()

        wg.Wait()
    }
    ```

    ##### ä¸ºä»€ä¹ˆæ­£ç¡®çš„æ“ä½œé¡ºåºèƒ½é¿å…é—®é¢˜ï¼Ÿ

    1. **å…ˆåŠ é”ã€ä¿®æ”¹æ•°æ®ï¼Œå†è§£é”**ï¼šç¡®ä¿æ•°æ®åœ¨ä¿®æ”¹è¿‡ç¨‹ä¸­ä¸ä¼šè¢«å…¶ä»–çº¿ç¨‹è¯»å–ã€‚  
    2. **å…ˆæ›´æ–°æ•°æ®ï¼Œå†é€šçŸ¥å…¶ä»–çº¿ç¨‹ï¼ˆè§£é”ï¼‰**ï¼šä¿è¯å…¶ä»–çº¿ç¨‹è¯»å–åˆ°çš„æ˜¯æ­£ç¡®çš„å€¼ã€‚  
    3. **é¿å…æ•°æ®ç«äº‰**ï¼šå¤šä¸ªçº¿ç¨‹ä¸ä¼šåŒæ—¶è®¿é—®ä¸ä¸€è‡´çš„æ•°æ®ã€‚

## å¹¶å‘å®æˆ˜

- **é¿å…é˜»å¡ï¼Œé¿å…ç«äº‰**  
- **ä¼˜å…ˆä½¿ç”¨é€šé“é¿å…å…±äº«çŠ¶æ€**  
- **å½“é€šé“ä¸é€‚ç”¨æ—¶**ï¼š
    - å…ˆå°è¯• `sync` åŒ…çš„å·¥å…·  
    - åœ¨ç®€å•åœºæ™¯æˆ–å¿…è¦æ—¶ï¼Œå°è¯•æ— é”ä»£ç   